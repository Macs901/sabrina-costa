#!/usr/bin/env node

/**
 * Auto-Generate API Documentation - Dashboard Sabrina Costa
 * Script para gerar documenta√ß√£o da API automaticamente usando swagger-jsdoc
 * 
 * @version 1.0.0
 * @author Marco Cardoso
 * @lastUpdated 2025-10-23
 */

const swaggerJsdoc = require('swagger-jsdoc');
const fs = require('fs');
const path = require('path');

// ============================================================================
// CONFIGURA√á√ÉO DO SWAGGER-JSDOC
// ============================================================================

const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Dashboard Sabrina Costa API',
      version: '1.0.0',
      description: `
        API RESTful completa para o Dashboard Sabrina Costa.
        
        ## Funcionalidades
        
        - üîê **Autentica√ß√£o JWT** - Sistema seguro de login
        - üìä **Gest√£o de M√©tricas** - CRUD completo de m√©tricas do Instagram
        - üìÖ **Cronograma de Posts** - Agendamento e gest√£o de conte√∫do
        - üö® **Sistema de Alertas** - Notifica√ß√µes autom√°ticas via WhatsApp
        - üé£ **Ganchos Virais** - Biblioteca de hooks para conte√∫do
        - üîó **Webhooks** - Integra√ß√£o com sistemas externos
        - ‚öôÔ∏è **Configura√ß√µes** - Gest√£o de par√¢metros do sistema
        
        ## Autentica√ß√£o
        
        Todos os endpoints protegidos exigem um JWT v√°lido no header \`Authorization\`:
        \`\`\`
        Authorization: Bearer <seu-jwt-token>
        \`\`\`
        
        ## Rate Limiting
        
        A API implementa rate limiting para garantir estabilidade:
        - **100 requests/minuto** por IP
        - **1000 requests/hora** por usu√°rio autenticado
        
        ## C√≥digos de Resposta
        
        - \`200 OK\` - Requisi√ß√£o bem-sucedida
        - \`201 Created\` - Recurso criado com sucesso
        - \`400 Bad Request\` - Dados inv√°lidos
        - \`401 Unauthorized\` - Token ausente/inv√°lido
        - \`403 Forbidden\` - Acesso negado
        - \`404 Not Found\` - Recurso n√£o encontrado
        - \`429 Too Many Requests\` - Rate limit excedido
        - \`500 Internal Server Error\` - Erro interno
      `,
      contact: {
        name: 'Marco Cardoso',
        email: 'marco@example.com',
        url: 'https://github.com/Marcocardoso91'
      },
      license: {
        name: 'MIT',
        url: 'https://opensource.org/licenses/MIT'
      }
    },
    servers: [
      {
        url: 'https://backend-smoky-theta.vercel.app/api',
        description: 'Servidor de Produ√ß√£o'
      },
      {
        url: 'http://localhost:3000/api',
        description: 'Servidor de Desenvolvimento'
      }
    ],
    tags: [
      {
        name: 'Autentica√ß√£o',
        description: 'Endpoints para autentica√ß√£o e gest√£o de usu√°rios'
      },
      {
        name: 'M√©tricas',
        description: 'Gest√£o de m√©tricas de desempenho do Instagram'
      },
      {
        name: 'Cronograma',
        description: 'Agendamento e gest√£o de posts'
      },
      {
        name: 'Alertas',
        description: 'Sistema de notifica√ß√µes e alertas'
      },
      {
        name: 'Ganchos',
        description: 'Biblioteca de ganchos virais e categorias'
      },
      {
        name: 'Webhooks',
        description: 'Endpoints para integra√ß√£o externa'
      },
      {
        name: 'Configura√ß√µes',
        description: 'Gest√£o de configura√ß√µes do sistema'
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
          description: 'JWT token obtido atrav√©s do endpoint /auth/login'
        }
      },
      schemas: {
        User: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              format: 'uuid',
              description: 'ID √∫nico do usu√°rio'
            },
            email: {
              type: 'string',
              format: 'email',
              description: 'Email do usu√°rio'
            },
            name: {
              type: 'string',
              description: 'Nome do usu√°rio'
            },
            role: {
              type: 'string',
              enum: ['user', 'admin'],
              description: 'Papel do usu√°rio no sistema'
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data de cria√ß√£o'
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data da √∫ltima atualiza√ß√£o'
            }
          },
          required: ['id', 'email', 'name', 'role']
        },
        Metric: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              format: 'uuid',
              description: 'ID √∫nico da m√©trica'
            },
            date: {
              type: 'string',
              format: 'date',
              description: 'Data da m√©trica (YYYY-MM-DD)'
            },
            reach: {
              type: 'integer',
              minimum: 0,
              description: 'Alcance (n√∫mero de pessoas)'
            },
            ctr: {
              type: 'number',
              format: 'float',
              minimum: 0,
              maximum: 100,
              description: 'Taxa de cliques (%)'
            },
            cpc: {
              type: 'number',
              format: 'float',
              minimum: 0,
              description: 'Custo por clique (R$)'
            },
            cpm: {
              type: 'number',
              format: 'float',
              minimum: 0,
              description: 'Custo por mil impress√µes (R$)'
            },
            frequency: {
              type: 'number',
              format: 'float',
              minimum: 0,
              description: 'Frequ√™ncia de exibi√ß√£o'
            },
            profileVisits: {
              type: 'integer',
              minimum: 0,
              description: 'Visitas ao perfil'
            },
            newFollowers: {
              type: 'integer',
              minimum: 0,
              description: 'Novos seguidores'
            },
            cost: {
              type: 'number',
              format: 'float',
              minimum: 0,
              description: 'Custo total (R$)'
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data de cria√ß√£o'
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data da √∫ltima atualiza√ß√£o'
            }
          },
          required: ['date']
        },
        Post: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              format: 'uuid',
              description: 'ID √∫nico do post'
            },
            date: {
              type: 'string',
              format: 'date',
              description: 'Data agendada para o post'
            },
            weekNumber: {
              type: 'integer',
              minimum: 1,
              maximum: 52,
              description: 'N√∫mero da semana'
            },
            format: {
              type: 'string',
              enum: ['carousel', 'reel', 'story', 'post'],
              description: 'Formato do conte√∫do'
            },
            theme: {
              type: 'string',
              description: 'Tema do post'
            },
            hook: {
              type: 'string',
              description: 'Gancho viral do post'
            },
            cta: {
              type: 'string',
              description: 'Call-to-action'
            },
            status: {
              type: 'string',
              enum: ['planned', 'published', 'cancelled'],
              description: 'Status do post'
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data de cria√ß√£o'
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data da √∫ltima atualiza√ß√£o'
            }
          },
          required: ['date', 'format', 'theme']
        },
        Alert: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              format: 'uuid',
              description: 'ID √∫nico do alerta'
            },
            type: {
              type: 'string',
              description: 'Tipo do alerta'
            },
            message: {
              type: 'string',
              description: 'Mensagem do alerta'
            },
            thresholdValue: {
              type: 'number',
              format: 'float',
              description: 'Valor limite'
            },
            actualValue: {
              type: 'number',
              format: 'float',
              description: 'Valor atual'
            },
            date: {
              type: 'string',
              format: 'date',
              description: 'Data do alerta'
            },
            sentAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data de envio'
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data de cria√ß√£o'
            }
          },
          required: ['type', 'message', 'date']
        },
        Hook: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              format: 'uuid',
              description: 'ID √∫nico do gancho'
            },
            title: {
              type: 'string',
              description: 'T√≠tulo do gancho'
            },
            content: {
              type: 'string',
              description: 'Conte√∫do do gancho'
            },
            category: {
              type: 'string',
              description: 'Categoria do gancho'
            },
            usageCount: {
              type: 'integer',
              minimum: 0,
              description: 'N√∫mero de usos'
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data de cria√ß√£o'
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'Data da √∫ltima atualiza√ß√£o'
            }
          },
          required: ['title', 'content', 'category']
        },
        Error: {
          type: 'object',
          properties: {
            message: {
              type: 'string',
              description: 'Mensagem de erro'
            },
            code: {
              type: 'string',
              description: 'C√≥digo do erro'
            },
            details: {
              type: 'object',
              description: 'Detalhes adicionais do erro'
            }
          },
          required: ['message']
        },
        Success: {
          type: 'object',
          properties: {
            message: {
              type: 'string',
              description: 'Mensagem de sucesso'
            },
            data: {
              type: 'object',
              description: 'Dados retornados'
            }
          },
          required: ['message']
        }
      }
    },
    security: [
      {
        bearerAuth: []
      }
    ]
  },
  apis: [
    // Incluir todos os arquivos de rotas do backend
    './backend/routes/*.js',
    './backend/controllers/*.js',
    './backend/middleware/*.js'
  ]
};

// ============================================================================
// FUN√á√ÉO PRINCIPAL
// ============================================================================

function generateApiDocs() {
  console.log('üöÄ Gerando documenta√ß√£o da API...');
  
  try {
    // Gerar especifica√ß√£o OpenAPI
    const swaggerSpec = swaggerJsdoc(swaggerOptions);
    
    // Validar especifica√ß√£o
    if (!swaggerSpec || !swaggerSpec.paths) {
      throw new Error('Especifica√ß√£o OpenAPI inv√°lida');
    }
    
    // Criar diret√≥rio de sa√≠da se n√£o existir
    const outputDir = path.join(__dirname, '..', 'api');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    // Salvar especifica√ß√£o YAML
    const yamlPath = path.join(outputDir, 'openapi.yaml');
    const yamlContent = convertToYAML(swaggerSpec);
    fs.writeFileSync(yamlPath, yamlContent);
    console.log(`‚úÖ Especifica√ß√£o YAML salva em: ${yamlPath}`);
    
    // Salvar especifica√ß√£o JSON
    const jsonPath = path.join(outputDir, 'openapi.json');
    fs.writeFileSync(jsonPath, JSON.stringify(swaggerSpec, null, 2));
    console.log(`‚úÖ Especifica√ß√£o JSON salva em: ${jsonPath}`);
    
    // Gerar estat√≠sticas
    const stats = generateStats(swaggerSpec);
    console.log('\nüìä Estat√≠sticas da API:');
    console.log(`   - Endpoints: ${stats.endpoints}`);
    console.log(`   - M√©todos HTTP: ${stats.methods.join(', ')}`);
    console.log(`   - Tags: ${stats.tags.join(', ')}`);
    console.log(`   - Schemas: ${stats.schemas}`);
    
    // Gerar relat√≥rio de cobertura
    generateCoverageReport(swaggerSpec);
    
    console.log('\nüéâ Documenta√ß√£o da API gerada com sucesso!');
    
  } catch (error) {
    console.error('‚ùå Erro ao gerar documenta√ß√£o:', error.message);
    process.exit(1);
  }
}

// ============================================================================
// FUN√á√ïES AUXILIARES
// ============================================================================

function convertToYAML(obj) {
  // Convers√£o simples para YAML (em produ√ß√£o, usar biblioteca como js-yaml)
  let yaml = 'openapi: 3.0.0\n';
  yaml += 'info:\n';
  yaml += `  title: ${obj.info.title}\n`;
  yaml += `  version: ${obj.info.version}\n`;
  yaml += `  description: |\n`;
  yaml += `    ${obj.info.description.split('\n').map(line => `    ${line}`).join('\n')}\n`;
  
  // Adicionar servidores
  yaml += 'servers:\n';
  obj.servers.forEach(server => {
    yaml += `  - url: ${server.url}\n`;
    yaml += `    description: ${server.description}\n`;
  });
  
  // Adicionar tags
  yaml += 'tags:\n';
  obj.tags.forEach(tag => {
    yaml += `  - name: ${tag.name}\n`;
    yaml += `    description: ${tag.description}\n`;
  });
  
  // Adicionar componentes
  yaml += 'components:\n';
  yaml += '  securitySchemes:\n';
  yaml += '    bearerAuth:\n';
  yaml += '      type: http\n';
  yaml += '      scheme: bearer\n';
  yaml += '      bearerFormat: JWT\n';
  
  // Adicionar schemas
  yaml += '  schemas:\n';
  Object.entries(obj.components.schemas).forEach(([name, schema]) => {
    yaml += `    ${name}:\n`;
    yaml += `      type: ${schema.type}\n`;
    if (schema.properties) {
      yaml += '      properties:\n';
      Object.entries(schema.properties).forEach(([prop, propSchema]) => {
        yaml += `        ${prop}:\n`;
        yaml += `          type: ${propSchema.type}\n`;
        if (propSchema.description) {
          yaml += `          description: ${propSchema.description}\n`;
        }
        if (propSchema.format) {
          yaml += `          format: ${propSchema.format}\n`;
        }
        if (propSchema.enum) {
          yaml += `          enum: [${propSchema.enum.join(', ')}]\n`;
        }
        if (propSchema.minimum !== undefined) {
          yaml += `          minimum: ${propSchema.minimum}\n`;
        }
        if (propSchema.maximum !== undefined) {
          yaml += `          maximum: ${propSchema.maximum}\n`;
        }
      });
    }
    if (schema.required) {
      yaml += `      required: [${schema.required.join(', ')}]\n`;
    }
  });
  
  // Adicionar paths (simplificado)
  yaml += 'paths:\n';
  Object.entries(obj.paths).forEach(([path, methods]) => {
    yaml += `  ${path}:\n`;
    Object.entries(methods).forEach(([method, spec]) => {
      yaml += `    ${method}:\n`;
      yaml += `      summary: ${spec.summary}\n`;
      if (spec.tags) {
        yaml += `      tags: [${spec.tags.join(', ')}]\n`;
      }
      if (spec.security) {
        yaml += '      security:\n';
        yaml += '        - bearerAuth: []\n';
      }
      if (spec.responses) {
        yaml += '      responses:\n';
        Object.entries(spec.responses).forEach(([code, response]) => {
          yaml += `        ${code}:\n`;
          yaml += `          description: ${response.description}\n`;
        }));
      }
    });
  });
  
  return yaml;
}

function generateStats(spec) {
  const endpoints = Object.keys(spec.paths).length;
  const methods = new Set();
  const tags = new Set();
  const schemas = Object.keys(spec.components.schemas).length;
  
  Object.values(spec.paths).forEach(path => {
    Object.values(path).forEach(method => {
      if (method.tags) {
        method.tags.forEach(tag => tags.add(tag));
      }
      if (method.summary) {
        methods.add(method.summary.split(' ')[0]);
      }
    });
  });
  
  return {
    endpoints,
    methods: Array.from(methods),
    tags: Array.from(tags),
    schemas
  };
}

function generateCoverageReport(spec) {
  const reportPath = path.join(__dirname, '..', 'api', 'coverage-report.md');
  
  let report = '# üìä Relat√≥rio de Cobertura da API\n\n';
  report += `**Gerado em:** ${new Date().toLocaleString('pt-BR')}\n\n`;
  
  // Estat√≠sticas gerais
  const stats = generateStats(spec);
  report += '## üìà Estat√≠sticas Gerais\n\n';
  report += `- **Total de Endpoints:** ${stats.endpoints}\n`;
  report += `- **Total de Schemas:** ${stats.schemas}\n`;
  report += `- **Tags:** ${stats.tags.join(', ')}\n\n`;
  
  // Cobertura por tag
  report += '## üè∑Ô∏è Cobertura por Tag\n\n';
  stats.tags.forEach(tag => {
    const tagEndpoints = Object.entries(spec.paths)
      .filter(([path, methods]) => 
        Object.values(methods).some(method => method.tags?.includes(tag))
      ).length;
    
    report += `- **${tag}:** ${tagEndpoints} endpoints\n`;
  });
  
  // Endpoints por m√©todo HTTP
  report += '\n## üîÑ Endpoints por M√©todo HTTP\n\n';
  const methodCounts = {};
  Object.values(spec.paths).forEach(methods => {
    Object.keys(methods).forEach(method => {
      methodCounts[method.toUpperCase()] = (methodCounts[method.toUpperCase()] || 0) + 1;
    });
  });
  
  Object.entries(methodCounts).forEach(([method, count]) => {
    report += `- **${method}:** ${count} endpoints\n`;
  });
  
  // Schemas mais utilizados
  report += '\n## üìã Schemas Mais Utilizados\n\n';
  const schemaUsage = {};
  Object.values(spec.paths).forEach(methods => {
    Object.values(methods).forEach(method => {
      if (method.responses) {
        Object.values(method.responses).forEach(response => {
          if (response.content) {
            Object.values(response.content).forEach(content => {
              if (content.schema?.$ref) {
                const schemaName = content.schema.$ref.split('/').pop();
                schemaUsage[schemaName] = (schemaUsage[schemaName] || 0) + 1;
              }
            });
          }
        });
      }
    });
  });
  
  Object.entries(schemaUsage)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 10)
    .forEach(([schema, count]) => {
      report += `- **${schema}:** ${count} usos\n`;
    });
  
  // Recomenda√ß√µes
  report += '\n## üí° Recomenda√ß√µes\n\n';
  report += '- ‚úÖ Documenta√ß√£o completa gerada\n';
  report += '- ‚úÖ Schemas bem definidos\n';
  report += '- ‚úÖ Tags organizadas\n';
  report += '- üîÑ Considerar adicionar mais exemplos\n';
  report += '- üîÑ Implementar testes automatizados\n';
  report += '- üîÑ Adicionar valida√ß√£o de schemas\n';
  
  fs.writeFileSync(reportPath, report);
  console.log(`üìä Relat√≥rio de cobertura salvo em: ${reportPath}`);
}

// ============================================================================
// EXECU√á√ÉO
// ============================================================================

if (require.main === module) {
  generateApiDocs();
}

module.exports = {
  generateApiDocs,
  swaggerOptions
};
